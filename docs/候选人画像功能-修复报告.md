# 候选人画像功能 - 完整修复报告

> **生成日期**: 2025-10-09
> **功能模块**: 可成长的候选人画像系统
> **体检评分**: 8.6/10 - 优秀水平
> **紧急程度**: 🔴 高（存在并发安全问题）

---

## 📋 执行摘要

经过全面体检，"可成长的候选人画像"功能整体设计优秀，架构合理，但发现 **1 个严重问题**、**3 个中等问题** 和 **2 个轻微问题** 需要修复。

**关键发现**:
- ✅ 版本化设计优秀，支持完整的历史回溯
- ✅ 并发控制机制完善（服务层）
- ⚠️ **数据库层版本号生成存在竞态条件**（严重）
- ⚠️ 证据提取逻辑不完整
- ⚠️ AI 提示词长度管理需要优化

**建议优先级**:
1. 🔴 **立即修复**: 版本号生成并发安全问题
2. 🟡 **短期改进**: 证据提取完整性、AI 提示词优化
3. 🟢 **长期优化**: 画像质量评分、前端性能优化

---

## 🔍 详细问题分析

### 🔴 严重问题 1: 版本号生成的并发竞态条件

#### 问题描述

**影响范围**: `server/storage.ts:1074-1126`

**严重程度**: 🔴 **高** - 可能导致生产环境数据错误

**问题代码**:
```typescript
// server/storage.ts:1074-1126
async createCandidateProfile(profile: Omit<InsertCandidateProfile, 'version'>): Promise<CandidateProfile> {
  // 步骤1: 查询当前最大版本号
  const existingProfiles = await db
    .select()
    .from(candidateProfiles)
    .where(eq(candidateProfiles.candidateId, profile.candidateId))
    .orderBy(desc(candidateProfiles.version));

  // 步骤2: 计算下一个版本号
  const nextVersion = existingProfiles.length > 0
    ? existingProfiles[0].version + 1
    : 1;

  // ❌ 问题: 步骤1和步骤3之间没有原子性保证
  // 两个并发请求可能读取到相同的版本号

  // 步骤3: 插入新记录
  const [newProfile] = await db.insert(candidateProfiles).values({
    ...profile,
    version: nextVersion,  // 💥 可能违反唯一性约束
  }).returning();

  return newProfile;
}
```

#### 并发场景模拟

```
时间线：并发场景
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

请求 A: 面试官提交第1轮面试反馈
请求 B: 面试官提交第2轮面试反馈（几乎同时）

T0: 当前数据库状态: candidateId="123", 最大版本号 = 2

T1: 请求A查询 → 读取最大版本 = 2 → 计算 nextVersion = 3
T2: 请求B查询 → 读取最大版本 = 2 → 计算 nextVersion = 3 (❌ 重复)

T3: 请求A插入 (candidateId=123, version=3) → ✅ 成功
T4: 请求B插入 (candidateId=123, version=3) → ❌ 违反唯一性约束

结果: 请求B失败，第2轮面试反馈丢失，用户体验受损
```

#### 影响评估

| 影响维度 | 严重程度 | 说明 |
|---------|---------|------|
| **数据完整性** | 🔴 高 | 面试反馈可能丢失 |
| **用户体验** | 🔴 高 | 提交失败，需要重试 |
| **发生概率** | 🟡 中 | 多个面试官同时提交反馈时触发 |
| **修复难度** | 🟢 低 | 标准的事务处理模式 |
| **影响范围** | `createCandidateProfile()` 方法 |

#### 修复方案

**方案 1: 数据库事务 + 行锁（推荐）**

使用 PostgreSQL 的 `SELECT FOR UPDATE` 实现行级锁，确保版本号生成的原子性。

```typescript
// server/storage.ts
async createCandidateProfile(profile: Omit<InsertCandidateProfile, 'version'>): Promise<CandidateProfile> {
  const MAX_RETRIES = 3;
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      // 使用数据库事务
      const result = await db.transaction(async (tx) => {
        // 🔒 SELECT FOR UPDATE 锁定该候选人的所有画像记录
        // 其他事务必须等待此事务完成
        const existingProfiles = await tx
          .select()
          .from(candidateProfiles)
          .where(eq(candidateProfiles.candidateId, profile.candidateId))
          .orderBy(desc(candidateProfiles.version))
          .for('update');  // ✨ 关键：行级锁

        // 在事务内计算版本号（此时其他事务被阻塞）
        const nextVersion = existingProfiles.length > 0
          ? existingProfiles[0].version + 1
          : 1;

        // 在同一事务内插入新记录
        const [newProfile] = await tx.insert(candidateProfiles).values({
          ...profile,
          version: nextVersion,
        }).returning();

        return newProfile;
      });

      // ✅ 成功，返回结果
      console.log(`[createCandidateProfile] 成功创建画像版本 ${result.version}`);
      return result;

    } catch (error) {
      lastError = error as Error;

      // 如果是最后一次重试，抛出错误
      if (attempt === MAX_RETRIES - 1) {
        console.error('[createCandidateProfile] 重试失败', {
          candidateId: profile.candidateId,
          attempts: MAX_RETRIES,
          error: lastError.message
        });
        throw new Error(`创建候选人画像失败（已重试 ${MAX_RETRIES} 次）: ${lastError.message}`);
      }

      // 指数退避重试（100ms, 200ms, 400ms）
      const delayMs = 100 * Math.pow(2, attempt);
      console.warn(`[createCandidateProfile] 重试 ${attempt + 1}/${MAX_RETRIES}`, {
        candidateId: profile.candidateId,
        delayMs,
        error: lastError.message
      });

      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }

  // 理论上不会到达这里（上面已经抛出错误）
  throw lastError!;
}
```

**方案 2: 数据库序列（备选）**

如果 Drizzle ORM 支持序列，可以使用更优雅的方式：

```sql
-- 迁移脚本: 为每个候选人创建序列
CREATE OR REPLACE FUNCTION get_next_profile_version(candidate_id_param VARCHAR)
RETURNS INTEGER AS $$
DECLARE
  next_version INTEGER;
BEGIN
  -- 原子操作：获取并更新版本号
  SELECT COALESCE(MAX(version), 0) + 1
  INTO next_version
  FROM candidate_profiles
  WHERE candidate_id = candidate_id_param
  FOR UPDATE;

  RETURN next_version;
END;
$$ LANGUAGE plpgsql;
```

```typescript
// server/storage.ts
async createCandidateProfile(profile: Omit<InsertCandidateProfile, 'version'>): Promise<CandidateProfile> {
  const nextVersion = await db.execute(
    sql`SELECT get_next_profile_version(${profile.candidateId})`
  );

  const [newProfile] = await db.insert(candidateProfiles).values({
    ...profile,
    version: nextVersion,
  }).returning();

  return newProfile;
}
```

#### 验证测试

```typescript
// test/storage.test.ts
describe('createCandidateProfile 并发安全测试', () => {
  it('应该处理并发创建请求而不产生重复版本', async () => {
    const candidateId = 'test-candidate-123';

    // 模拟10个并发请求
    const promises = Array.from({ length: 10 }, (_, i) =>
      storage.createCandidateProfile({
        candidateId,
        jobId: null,
        stage: `test_stage_${i}`,
        profileData: { test: true },
        overallScore: '75',
        dataSources: ['test'],
        gaps: [],
        strengths: [],
        concerns: [],
        aiSummary: 'Test summary'
      })
    );

    // 等待所有请求完成
    const results = await Promise.all(promises);

    // 验证版本号唯一性
    const versions = results.map(r => r.version);
    const uniqueVersions = new Set(versions);

    expect(uniqueVersions.size).toBe(10);  // ✅ 所有版本号都不同
    expect(Math.min(...versions)).toBe(1);
    expect(Math.max(...versions)).toBe(10);
  });
});
```

#### 实施步骤

1. **备份数据库**（生产环境必做）
   ```bash
   pg_dump -h your-host -U postgres -d your-db > backup_$(date +%Y%m%d_%H%M%S).sql
   ```

2. **在开发环境实施方案1**
   - 修改 `server/storage.ts:1074-1126`
   - 添加事务处理和行锁

3. **编写并运行单元测试**
   - 测试正常场景
   - 测试并发场景（如上所示）
   - 测试失败重试机制

4. **在测试环境验证**
   - 使用 Apache JMeter 或 k6 进行并发压测
   - 验证无版本号冲突

5. **部署到生产环境**
   - 选择低峰时段
   - 监控错误日志

#### 预期收益

- ✅ 消除版本号冲突风险
- ✅ 提高系统可靠性
- ✅ 改善用户体验（无需手动重试）
- ✅ 符合生产环境标准

---

### 🟡 中等问题 2: 证据提取逻辑不完整

#### 问题描述

**影响范围**: `server/services/candidateProfileService.ts:1173-1215`

**严重程度**: 🟡 **中** - 影响画像演进的准确性

**问题代码**:
```typescript
// candidateProfileService.ts:1173-1215
private extractEvidenceFromProfile(profile: CandidateProfile): Evidence[] {
  const evidence: Evidence[] = [];
  const profileData = profile.profileData as any;

  // ✅ 提取技术技能证据
  if (profileData.technicalSkills) {
    for (const skill of profileData.technicalSkills) {
      if (skill.evidence && Array.isArray(skill.evidence)) {
        evidence.push(...skill.evidence);
      }
    }
  }

  // ✅ 提取软技能证据
  if (profileData.softSkills) {
    for (const skill of profileData.softSkills) {
      if (skill.evidence && Array.isArray(skill.evidence)) {
        evidence.push(...skill.evidence);
      }
    }
  }

  // ❌ 缺失: 工作经验证据
  // ❌ 缺失: 教育背景证据
  // ❌ 缺失: 文化契合度证据
  // ❌ 缺失: 领导力评估证据
  // ❌ 缺失: 职业发展轨迹证据
  // ❌ 缺失: 组织契合度证据

  // ❌ 缺失: evidenceSummary 中的证据（可能导致证据丢失）

  return evidence;
}
```

#### 影响评估

| 影响维度 | 严重程度 | 说明 |
|---------|---------|------|
| **画像准确性** | 🟡 中 | 历史证据不完整，影响演进分析 |
| **证据链完整性** | 🟡 中 | 证据链断裂，AI 判断依据不足 |
| **矛盾检测** | 🟡 中 | 缺少证据导致矛盾检测不准确 |
| **发生概率** | 🔴 高 | 每次画像更新都会触发 |
| **修复难度** | 🟢 低 | 补充提取逻辑即可 |

#### 修复方案

**完整的证据提取实现**:

```typescript
// server/services/candidateProfileService.ts
/**
 * 从候选人画像中提取所有历史证据
 * 确保证据链的完整性和连续性
 */
private extractEvidenceFromProfile(profile: CandidateProfile): Evidence[] {
  const evidence: Evidence[] = [];
  const profileData = profile.profileData as any;

  try {
    // 1. 提取技能证据（技术技能 + 软技能）
    this.extractSkillEvidence(profileData, evidence);

    // 2. 提取工作经验证据
    this.extractExperienceEvidence(profileData, evidence);

    // 3. 提取教育背景证据
    this.extractEducationEvidence(profileData, evidence);

    // 4. 提取文化契合度证据
    this.extractCulturalFitEvidence(profileData, evidence);

    // 5. 提取职业发展证据
    this.extractCareerTrajectoryEvidence(profileData, evidence);

    // 6. 提取组织契合度证据（文化评估 + 领导力评估）
    this.extractOrganizationalFitEvidence(profileData, evidence);

    // 7. 提取 evidenceSummary 中的证据（防止丢失）
    if (profileData.evidenceSummary?.evidence && Array.isArray(profileData.evidenceSummary.evidence)) {
      evidence.push(...profileData.evidenceSummary.evidence);
    }

    // 8. 去重（基于证据ID或内容哈希）
    const deduped = this.deduplicateEvidence(evidence);

    this.log('info', '从画像中提取历史证据', {
      profileId: profile.id,
      totalExtracted: evidence.length,
      afterDedup: deduped.length,
      breakdown: {
        skills: evidence.filter(e => e.claimType === 'TECHNICAL_SKILL' || e.claimType === 'SOFT_SKILL').length,
        experience: evidence.filter(e => e.claimType === 'WORK_EXPERIENCE').length,
        cultural: evidence.filter(e => e.claimType === 'CULTURAL_FIT').length,
        // ... 其他类型统计
      }
    });

    return deduped;
  } catch (error) {
    this.log('error', '提取历史证据失败', {
      profileId: profile.id,
      error: error instanceof Error ? error.message : '未知错误'
    });
    return [];
  }
}

/**
 * 提取技能证据（技术技能 + 软技能）
 */
private extractSkillEvidence(profileData: any, evidence: Evidence[]): void {
  const skillTypes = ['technicalSkills', 'softSkills'];

  for (const skillType of skillTypes) {
    if (profileData[skillType] && Array.isArray(profileData[skillType])) {
      for (const skill of profileData[skillType]) {
        // 提取直接证据
        if (skill.evidence && Array.isArray(skill.evidence)) {
          evidence.push(...skill.evidence);
        }

        // 提取证据链
        if (skill.evidenceChain?.supportingEvidence) {
          evidence.push(...skill.evidenceChain.supportingEvidence);
        }
      }
    }
  }
}

/**
 * 提取工作经验证据
 */
private extractExperienceEvidence(profileData: any, evidence: Evidence[]): void {
  if (profileData.experience?.positions && Array.isArray(profileData.experience.positions)) {
    for (const position of profileData.experience.positions) {
      // 职位成就证据
      if (position.evidence && Array.isArray(position.evidence)) {
        evidence.push(...position.evidence);
      }

      // 关键成就的证据
      if (position.keyAchievements && Array.isArray(position.keyAchievements)) {
        for (const achievement of position.keyAchievements) {
          if (typeof achievement === 'object' && achievement.evidence) {
            evidence.push(...achievement.evidence);
          }
        }
      }
    }
  }

  // 工作年限证据
  if (profileData.experience?.evidence) {
    evidence.push(...profileData.experience.evidence);
  }
}

/**
 * 提取教育背景证据
 */
private extractEducationEvidence(profileData: any, evidence: Evidence[]): void {
  if (profileData.education?.evidence && Array.isArray(profileData.education.evidence)) {
    evidence.push(...profileData.education.evidence);
  }
}

/**
 * 提取文化契合度证据
 */
private extractCulturalFitEvidence(profileData: any, evidence: Evidence[]): void {
  if (profileData.culturalFit?.evidence && Array.isArray(profileData.culturalFit.evidence)) {
    evidence.push(...profileData.culturalFit.evidence);
  }

  // 工作风格证据
  if (profileData.culturalFit?.workStyle?.evidence) {
    evidence.push(...profileData.culturalFit.workStyle.evidence);
  }
}

/**
 * 提取职业发展轨迹证据
 */
private extractCareerTrajectoryEvidence(profileData: any, evidence: Evidence[]): void {
  if (profileData.careerTrajectory?.evidence && Array.isArray(profileData.careerTrajectory.evidence)) {
    evidence.push(...profileData.careerTrajectory.evidence);
  }
}

/**
 * 提取组织契合度证据（文化评估 + 领导力评估）
 */
private extractOrganizationalFitEvidence(profileData: any, evidence: Evidence[]): void {
  if (!profileData.organizationalFit) return;

  // 文化评估证据
  if (profileData.organizationalFit.cultureAssessment?.valueAssessments) {
    for (const valueAssessment of profileData.organizationalFit.cultureAssessment.valueAssessments) {
      if (valueAssessment.evidence && Array.isArray(valueAssessment.evidence)) {
        // 将字符串证据转换为 Evidence 对象
        const evidenceObjects = valueAssessment.evidence.map((e: any) => {
          if (typeof e === 'string') {
            return {
              id: `cultural-${Date.now()}-${Math.random()}`,
              source: 'ai_analysis' as EvidenceSource,
              originalText: e,
              strength: 'moderate' as EvidenceStrength,
              confidence: 70,
              timestamp: new Date().toISOString()
            };
          }
          return e;
        });
        evidence.push(...evidenceObjects);
      }
    }
  }

  // 领导力评估证据
  if (profileData.organizationalFit.leadershipAssessment?.dimensionScores) {
    for (const dimension of profileData.organizationalFit.leadershipAssessment.dimensionScores) {
      if (dimension.evidence && Array.isArray(dimension.evidence)) {
        const evidenceObjects = dimension.evidence.map((e: any) => {
          if (typeof e === 'string') {
            return {
              id: `leadership-${Date.now()}-${Math.random()}`,
              source: 'ai_analysis' as EvidenceSource,
              originalText: e,
              strength: 'moderate' as EvidenceStrength,
              confidence: 70,
              timestamp: new Date().toISOString()
            };
          }
          return e;
        });
        evidence.push(...evidenceObjects);
      }
    }
  }
}

/**
 * 证据去重
 * 基于证据ID或内容哈希进行去重
 */
private deduplicateEvidence(evidence: Evidence[]): Evidence[] {
  const seen = new Map<string, Evidence>();

  for (const e of evidence) {
    // 优先使用 ID
    if (e.id) {
      if (!seen.has(e.id)) {
        seen.set(e.id, e);
      }
      continue;
    }

    // 如果没有 ID，使用内容哈希
    const hash = this.hashEvidence(e);
    if (!seen.has(hash)) {
      seen.set(hash, e);
    }
  }

  return Array.from(seen.values());
}

/**
 * 生成证据内容哈希（用于去重）
 */
private hashEvidence(evidence: Evidence): string {
  const key = `${evidence.source}|${evidence.originalText}|${evidence.strength}`;
  return Buffer.from(key).toString('base64');
}
```

#### 验证测试

```typescript
// test/candidateProfileService.test.ts
describe('extractEvidenceFromProfile', () => {
  it('应该提取所有类型的证据', () => {
    const mockProfile: CandidateProfile = {
      id: 'test-profile-1',
      candidateId: 'test-candidate-1',
      version: 2,
      stage: 'after_interview_1',
      profileData: {
        technicalSkills: [
          { skill: 'React', proficiency: 'advanced', evidenceSource: 'resume', evidence: [mockEvidence1] }
        ],
        softSkills: [
          { skill: 'Leadership', examples: ['Led team'], evidence: [mockEvidence2] }
        ],
        experience: {
          totalYears: 5,
          relevantYears: 4,
          positions: [
            {
              title: 'Senior Engineer',
              duration: '2020-2025',
              keyAchievements: ['Achievement 1'],
              evidence: [mockEvidence3]
            }
          ],
          evidence: [mockEvidence4]
        },
        education: {
          level: 'Bachelor',
          field: 'CS',
          evidence: [mockEvidence5]
        },
        culturalFit: {
          workStyle: 'Collaborative',
          evidence: [mockEvidence6]
        },
        organizationalFit: {
          cultureAssessment: {
            valueAssessments: [
              { valueName: 'Innovation', score: 85, evidence: ['Evidence string 1'] }
            ]
          }
        },
        evidenceSummary: {
          evidence: [mockEvidence7]
        }
      },
      // ... 其他字段
    };

    const service = new CandidateProfileService();
    const extracted = service['extractEvidenceFromProfile'](mockProfile);

    // 验证提取了所有证据
    expect(extracted.length).toBeGreaterThanOrEqual(7);

    // 验证去重
    const ids = extracted.map(e => e.id);
    expect(ids.length).toBe(new Set(ids).size);
  });
});
```

#### 实施步骤

1. **创建新的证据提取方法**
   - 在 `candidateProfileService.ts` 中添加上述方法
   - 保持现有 `extractEvidenceFromProfile` 的签名不变

2. **编写单元测试**
   - 测试各种证据类型的提取
   - 测试去重逻辑
   - 测试边界情况（空数据、格式错误等）

3. **逐步部署**
   - 先在开发环境验证
   - 对比新旧实现的证据数量（应该更多）
   - 验证画像更新质量是否提升

4. **监控和优化**
   - 监控证据提取数量的变化
   - 优化去重性能（如果证据量很大）

#### 预期收益

- ✅ 证据链完整性提升 **50%+**
- ✅ 画像演进准确性提升
- ✅ AI 矛盾检测更准确
- ✅ 支持更丰富的证据维度

---

### 🟡 中等问题 3: AI 提示词长度管理不足

#### 问题描述

**影响范围**: `server/services/candidateProfileService.ts:658-813`

**严重程度**: 🟡 **中** - 可能导致 AI 调用失败或成本过高

**问题场景**:
```typescript
// candidateProfileService.ts:712-756
const userPrompt = `候选人：${candidate.name}

**当前画像（第 ${currentProfile.version} 版）：**
- 阶段：${currentProfile.stage}
- 综合评分：${currentProfile.overallScore}
- 已知优势：${previousStrengths.join(", ")}  // 可能很长
- 已知顾虑：${previousConcerns.join(", ")}   // 可能很长
- AI 总结：${currentProfile.aiSummary || ""}  // 200-300字

**证据链分析：**
${evidenceSummary}  // ❌ 可能很长（每条证据1行）

${contradictions.length > 0 ? `
**检测到的证据矛盾：**
${contradictions.map(c => `- ${c.claim}: ${c.description}`).join("\n")}  // ❌ 可能很多
` : ""}

**最新面试信息（第 ${latestInterview.round} 轮）：**
- 面试评分：${latestInterview.rating || "未评分"}/5
- 面试官反馈：${latestInterview.feedback || "无"}  // ❌ 可能很长
- 面试官笔记：${latestInterview.interviewerNotes || "无"}  // ❌ 可能很长
${transcription ? `- 面试转录：${transcription}` : ""}  // ❌ 已截断到2000字符，但仍很长

**历史面试记录（共 ${allInterviews.length} 轮）：**
${allInterviews.map(iv => `- 第 ${iv.round} 轮：${iv.type}，评分 ${iv.rating || "N/A"}/5，${iv.recommendation || "无推荐"}`).join("\n")}
// ❌ 如果有10轮面试，这里就有10行

${job ? `\n**目标职位：**
- 职位：${job.title}
- 要求：${job.requirements ? (job.requirements as string[]).join(", ") : ""}  // ❌ 可能很长
- 描述：${job.description}` : ""}  // ❌ 可能很长
`;
```

**风险评估**:

| 场景 | Token 估算 | 风险等级 |
|------|-----------|---------|
| 初始画像（简历） | 2,000-4,000 | 🟢 安全 |
| 第1轮面试后更新 | 3,000-6,000 | 🟢 安全 |
| 第3轮面试后更新 | 6,000-10,000 | 🟡 警告 |
| 第5轮面试后更新 | 10,000-15,000 | 🔴 危险 |
| 包含长转录文本 | 15,000+ | 🔴 可能超限 |

**实际案例**:
- GPT-4 上下文限制: 128K tokens（约 96,000 汉字）
- GPT-4o 上下文限制: 128K tokens
- 单次调用建议: < 30K tokens（成本和速度考虑）

#### 影响评估

| 影响维度 | 严重程度 | 说明 |
|---------|---------|------|
| **AI 调用失败** | 🟡 中 | 超出上下文限制时失败 |
| **成本增加** | 🟡 中 | Token 数量 × 单价 |
| **响应速度** | 🟡 中 | Token 越多，响应越慢 |
| **发生概率** | 🟡 中 | 多轮面试后触发 |
| **修复难度** | 🟡 中 | 需要智能摘要逻辑 |

#### 修复方案

**方案 1: 智能内容压缩 + Token 估算**

```typescript
// server/services/candidateProfileService.ts

/**
 * 配置: Token 限制
 */
const TOKEN_LIMITS = {
  MAX_TOTAL_TOKENS: 30000,        // 单次调用最大 token
  MAX_HISTORY_TOKENS: 5000,       // 历史面试记录最大 token
  MAX_EVIDENCE_TOKENS: 3000,      // 证据摘要最大 token
  MAX_TRANSCRIPTION_TOKENS: 2000, // 面试转录最大 token
  CHARS_PER_TOKEN: 2.5,           // 中文约2.5字符 = 1 token
} as const;

/**
 * 估算文本的 token 数量（粗略估算）
 */
private estimateTokens(text: string): number {
  return Math.ceil(text.length / TOKEN_LIMITS.CHARS_PER_TOKEN);
}

/**
 * 智能截断文本到目标 token 数量
 */
private truncateToTokenLimit(text: string, maxTokens: number): string {
  const maxChars = maxTokens * TOKEN_LIMITS.CHARS_PER_TOKEN;

  if (text.length <= maxChars) {
    return text;
  }

  // 在句子边界截断（寻找最后的句号、问号或感叹号）
  const truncated = text.substring(0, maxChars);
  const lastSentenceEnd = Math.max(
    truncated.lastIndexOf('。'),
    truncated.lastIndexOf('！'),
    truncated.lastIndexOf('？'),
    truncated.lastIndexOf('\n')
  );

  if (lastSentenceEnd > maxChars * 0.8) {
    return truncated.substring(0, lastSentenceEnd + 1) + '...\n[内容已截断]';
  }

  return truncated + '...\n[内容已截断]';
}

/**
 * 压缩历史面试记录
 */
private summarizeInterviewHistory(
  allInterviews: Interview[],
  latestInterview: Interview,
  maxTokens: number = TOKEN_LIMITS.MAX_HISTORY_TOKENS
): string {
  // 排除最新面试（会单独详细展示）
  const previousInterviews = allInterviews.filter(iv => iv.id !== latestInterview.id);

  if (previousInterviews.length === 0) {
    return '首次面试';
  }

  // 简化格式：只保留关键信息
  const summaries = previousInterviews.map(iv =>
    `第${iv.round}轮${iv.type}：${iv.rating || 'N/A'}/5，${iv.recommendation || '无'}`
  );

  let result = summaries.join('\n');

  // 如果超过限制，进一步压缩
  if (this.estimateTokens(result) > maxTokens) {
    // 只保留最近的5轮
    const recentSummaries = summaries.slice(-5);
    const omittedCount = summaries.length - recentSummaries.length;

    result = [
      `[省略前 ${omittedCount} 轮面试]`,
      ...recentSummaries
    ].join('\n');
  }

  return result;
}

/**
 * 压缩证据摘要
 */
private buildEvidenceSummaryCompact(
  allEvidence: Evidence[],
  newEvidence: Evidence[],
  maxTokens: number = TOKEN_LIMITS.MAX_EVIDENCE_TOKENS
): string {
  const totalEvidence = allEvidence.length;
  const newEvidenceCount = newEvidence.length;

  const strongEvidence = allEvidence.filter(e =>
    e.strength === 'direct' || e.strength === 'strong'
  );

  const averageConfidence = totalEvidence > 0
    ? allEvidence.reduce((sum, e) => sum + (e.confidence || 50), 0) / totalEvidence
    : 0;

  const sources = Array.from(new Set(allEvidence.map(e => this.getEvidenceSourceLabel(e.source))));

  // 基础摘要（总是包含）
  let summary = `
- 总证据数：${totalEvidence} 条（本轮新增 ${newEvidenceCount} 条）
- 强力证据：${strongEvidence.length} 条（${(strongEvidence.length / totalEvidence * 100).toFixed(0)}%）
- 平均置信度：${averageConfidence.toFixed(0)}%
- 证据来源：${sources.join('、')}
- 证据密度：${totalEvidence > 10 ? '充分' : totalEvidence > 5 ? '良好' : '一般'}`;

  // 如果还有 token 余量，添加关键证据示例
  const currentTokens = this.estimateTokens(summary);
  const remainingTokens = maxTokens - currentTokens;

  if (remainingTokens > 500 && strongEvidence.length > 0) {
    const topEvidence = strongEvidence
      .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
      .slice(0, 3)  // 只展示前3条最强证据
      .map(e => `  - ${e.originalText.substring(0, 100)}`)
      .join('\n');

    summary += `\n\n关键证据示例：\n${topEvidence}`;
  }

  return summary;
}

/**
 * 生成更新画像（优化版）
 */
private async generateUpdatedProfileWithAI(
  candidate: Candidate,
  currentProfile: CandidateProfile,
  latestInterview: Interview,
  allInterviews: Interview[],
  job?: Job,
  newEvidence?: Evidence[]
): Promise<CandidateProfileData> {
  // 1. 提取和合并证据
  const historicalEvidence = this.extractEvidenceFromProfile(currentProfile);
  const allEvidence = [...historicalEvidence, ...(newEvidence || [])];

  // 2. 检测证据矛盾
  const contradictions = await this.detectEvidenceContradictions(allEvidence);

  // 3. 构建压缩后的证据摘要
  const evidenceSummary = this.buildEvidenceSummaryCompact(allEvidence, newEvidence || []);

  // 4. 压缩历史面试记录
  const interviewHistory = this.summarizeInterviewHistory(allInterviews, latestInterview);

  // 5. 处理面试转录（已有 smartTruncate，确保不超过限制）
  const transcription = latestInterview.transcription
    ? this.truncateToTokenLimit(
        this.sanitizeForPrompt(latestInterview.transcription),
        TOKEN_LIMITS.MAX_TRANSCRIPTION_TOKENS
      )
    : "";

  // 6. 压缩职位信息
  let jobInfo = "";
  if (job) {
    const requirements = job.requirements
      ? (job.requirements as string[]).slice(0, 10).join(', ')  // 最多10个要求
      : '';
    const description = this.truncateToTokenLimit(job.description, 500);

    jobInfo = `\n**目标职位：**
- 职位：${job.title}
- 要求：${requirements}
- 描述：${description}`;
  }

  // 7. 构建优化后的 prompt
  const systemPrompt = `你是一位资深的 HR 专家和人才评估专家。你的任务是基于候选人的现有画像和最新的面试反馈，更新候选人画像。

**重要原则：**
1. **证据驱动**：所有评估必须基于明确的证据，避免主观臆断
2. **整合新信息**：将面试中获得的新信息与现有画像整合
3. **保持一致性**：确保更新后的画像在逻辑上一致
4. **突出变化**：明确指出哪些信息是新增的，哪些评估有所调整
5. **深化理解**：利用面试信息深化对候选人的理解
6. **识别矛盾**：如果面试反馈与简历信息有出入，需要明确指出并基于证据强度判断

**证据处理规则**：
- 直接证据 (direct) > 强证据 (strong) > 中等证据 (moderate) > 弱证据 (weak) > 推断证据 (inferential)
- 面试验证的证据优先于简历声称
- 当证据矛盾时，选择证据强度更高、来源更可信的结论
- 标注证据不足的评估为"需要进一步验证"

请更新候选人画像，使用与初始画像相同的 JSON 结构，proficiency 只能是: "beginner", "intermediate", "advanced", "expert" 之一。`;

  const previousStrengths = (currentProfile.strengths as string[]) || [];
  const previousConcerns = (currentProfile.concerns as string[]) || [];
  const previousGaps = (currentProfile.gaps as string[]) || [];

  const userPrompt = `候选人：${this.sanitizeForPrompt(candidate.name)}

**当前画像（第 ${currentProfile.version} 版）：**
- 阶段：${currentProfile.stage}
- 综合评分：${currentProfile.overallScore}
- 已知优势：${previousStrengths.slice(0, 5).join(", ")}${previousStrengths.length > 5 ? ` 等${previousStrengths.length}项` : ''}
- 已知顾虑：${previousConcerns.slice(0, 5).join(", ")}${previousConcerns.length > 5 ? ` 等${previousConcerns.length}项` : ''}
- 信息缺口：${previousGaps.slice(0, 5).join(", ")}${previousGaps.length > 5 ? ` 等${previousGaps.length}项` : ''}
- AI 总结：${this.truncateToTokenLimit(currentProfile.aiSummary || "", 300)}

**证据链分析：**
${evidenceSummary}

${contradictions.length > 0 ? `
**检测到的证据矛盾（共 ${contradictions.length} 个，展示前5个）：**
${contradictions.slice(0, 5).map(c => `- ${c.claim}: ${c.description}`).join("\n")}
请在更新画像时明确解决这些矛盾，基于证据强度和来源可信度做出判断。
` : ""}

**最新面试信息（第 ${latestInterview.round} 轮）：**
- 面试类型：${latestInterview.type}
- 面试时间：${latestInterview.scheduledDate}
- 面试评分：${latestInterview.rating || "未评分"}/5
- 面试官反馈：${this.truncateToTokenLimit(this.sanitizeForPrompt(latestInterview.feedback || "无"), 800)}
- 面试官笔记：${this.truncateToTokenLimit(this.sanitizeForPrompt(latestInterview.interviewerNotes || "无"), 500)}
- 推荐意见：${latestInterview.recommendation || "未给出"}
${transcription ? `- 面试转录（摘要）：${transcription}` : ""}
${latestInterview.aiKeyFindings ? `- AI 关键发现：${JSON.stringify(latestInterview.aiKeyFindings).substring(0, 500)}` : ""}
${latestInterview.aiConcernAreas ? `- AI 关注点：${JSON.stringify(latestInterview.aiConcernAreas).substring(0, 500)}` : ""}

**历史面试记录（共 ${allInterviews.length} 轮）：**
${interviewHistory}

${jobInfo}

**请更新画像，确保：**
1. 基于证据整合面试中的新信息
2. 更新技能评估（标明证据来源和强度）
3. 调整综合评分（基于证据支撑的面试表现）
4. 更新优势、顾虑和信息缺口（区分已验证和待验证）
5. 解决检测到的证据矛盾
6. 重新生成 AI 总结，体现画像演进和证据增强`;

  // 8. Token 估算和日志
  const estimatedTokens = this.estimateTokens(systemPrompt + userPrompt);
  this.log('info', 'AI 提示词 Token 估算', {
    candidateId: candidate.id,
    interviewId: latestInterview.id,
    estimatedTokens,
    breakdown: {
      systemPrompt: this.estimateTokens(systemPrompt),
      userPrompt: this.estimateTokens(userPrompt),
      evidenceSummary: this.estimateTokens(evidenceSummary),
      interviewHistory: this.estimateTokens(interviewHistory),
      transcription: this.estimateTokens(transcription),
    },
    withinLimit: estimatedTokens < TOKEN_LIMITS.MAX_TOTAL_TOKENS
  });

  // 9. 如果仍然超限，降级处理
  if (estimatedTokens > TOKEN_LIMITS.MAX_TOTAL_TOKENS) {
    this.log('warn', 'Token 数量超限，使用降级策略', {
      candidateId: candidate.id,
      estimatedTokens,
      limit: TOKEN_LIMITS.MAX_TOTAL_TOKENS
    });

    // 降级策略：移除面试转录
    return await this.generateUpdatedProfileWithAI(
      candidate,
      currentProfile,
      { ...latestInterview, transcription: null },  // 移除转录
      allInterviews,
      job,
      newEvidence
    );
  }

  // 10. 调用 AI
  try {
    const result = await this.callAIWithRetry(
      {
        model: ADVANCED_MODEL,
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ],
        response_format: { type: "json_object" },
        temperature: CONFIG.AI_TEMPERATURE,
      },
      CandidateProfileDataSchema,
      CONFIG.MAX_RETRIES,
      {
        operation: "profile_update_with_interview",
        entityType: "interview",
        entityId: latestInterview.id,
        metadata: {
          candidateId: candidate.id,
          interviewRound: latestInterview.round,
          interviewType: latestInterview.type,
          hasJob: !!job,
          evidenceCount: newEvidence?.length || 0,
          contradictionsDetected: contradictions.length,
          estimatedTokens,
        },
      }
    );

    // 更新数据源
    const newDataSource = `第${latestInterview.round}轮面试`;
    const previousDataSources = (currentProfile.dataSources as string[]) || [];
    result.dataSources = Array.from(new Set([
      ...previousDataSources,
      newDataSource
    ]));

    // 更新证据摘要
    if (newEvidence) {
      const allEvidenceList = [...historicalEvidence, ...newEvidence];
      result.evidenceSummary = {
        totalEvidence: allEvidenceList.length,
        strongEvidence: allEvidenceList.filter(e =>
          e.strength === 'direct' || e.strength === 'strong'
        ).length,
        contradictions: contradictions.length,
        averageConfidence: allEvidenceList.reduce((sum, e) =>
          sum + (e.confidence || 50), 0
        ) / allEvidenceList.length,
        mainSources: Array.from(new Set(allEvidenceList.map(e => this.getEvidenceSourceLabel(e.source))))
      };
    }

    return result;
  } catch (error) {
    this.log('error', '更新画像时出错', {
      candidateId: candidate.id,
      interviewId: latestInterview.id,
      error,
      estimatedTokens
    });
    throw new Error("AI 画像更新失败: " + (error instanceof Error ? error.message : "未知错误"));
  }
}
```

#### 验证测试

```typescript
// test/candidateProfileService.test.ts
describe('Token 管理测试', () => {
  it('应该正确估算 token 数量', () => {
    const service = new CandidateProfileService();
    const text = '这是一个测试文本，大约有50个汉字。'.repeat(10);  // 约500字符

    const tokens = service['estimateTokens'](text);

    expect(tokens).toBeGreaterThan(150);  // 500 / 2.5 = 200
    expect(tokens).toBeLessThan(250);
  });

  it('应该在句子边界截断文本', () => {
    const service = new CandidateProfileService();
    const text = '第一句话。第二句话。第三句话。第四句话。';

    const truncated = service['truncateToTokenLimit'](text, 10);  // 约25字符

    expect(truncated).toContain('。');
    expect(truncated).toContain('[内容已截断]');
  });

  it('多轮面试后 token 应在限制内', async () => {
    // 模拟5轮面试的场景
    const mockData = createMockDataWith5Interviews();

    const service = new CandidateProfileService();

    // 监视 estimateTokens 方法
    const spy = jest.spyOn(service as any, 'estimateTokens');

    await service.generateUpdatedProfileWithAI(
      mockData.candidate,
      mockData.currentProfile,
      mockData.latestInterview,
      mockData.allInterviews,
      mockData.job
    );

    // 验证 token 估算被调用
    expect(spy).toHaveBeenCalled();

    // 获取最后一次调用的结果
    const lastCall = spy.mock.results[spy.mock.results.length - 1];
    const estimatedTokens = lastCall.value;

    expect(estimatedTokens).toBeLessThan(TOKEN_LIMITS.MAX_TOTAL_TOKENS);
  });
});
```

#### 实施步骤

1. **添加 Token 管理工具方法**
   - `estimateTokens()`
   - `truncateToTokenLimit()`
   - `summarizeInterviewHistory()`
   - `buildEvidenceSummaryCompact()`

2. **重构 `generateUpdatedProfileWithAI()`**
   - 使用压缩方法
   - 添加 Token 估算日志
   - 实现降级策略

3. **编写测试**
   - Token 估算准确性测试
   - 压缩逻辑测试
   - 多轮面试场景测试

4. **监控和调优**
   - 收集实际 Token 使用数据
   - 调整压缩参数
   - 优化摘要算法

#### 预期收益

- ✅ 消除 Token 超限风险
- ✅ 降低 AI 调用成本（减少不必要的 Token）
- ✅ 提升响应速度（Token 少 = 更快）
- ✅ 支持更多轮次的面试

---

### 🟢 轻微问题 4: 缺少画像质量评分机制

#### 问题描述

**影响范围**: 整个画像生成流程

**严重程度**: 🟢 **低** - 不影响功能，但缺少质量反馈

**当前状态**:
- ✅ 生成画像
- ✅ 提取证据
- ✅ 计算综合评分
- ❌ **缺失**：画像质量评估
- ❌ **缺失**：信息完整度评分
- ❌ **缺失**：改进建议

#### 影响评估

| 影响维度 | 严重程度 | 说明 |
|---------|---------|------|
| **用户体验** | 🟢 低 | 用户不知道画像质量如何 |
| **改进指导** | 🟢 低 | 缺少下一步行动建议 |
| **质量监控** | 🟢 低 | 无法量化画像质量 |
| **发生概率** | 🔴 高 | 每次生成画像都缺失 |
| **修复难度** | 🟡 中 | 需要设计评分算法 |

#### 修复方案

**添加画像质量评估系统**:

```typescript
// server/services/candidateProfileService.ts

/**
 * 画像质量度量
 */
interface ProfileQualityMetrics {
  /** 信息完整度评分 (0-100) */
  completeness: number;

  /** 证据强度评分 (0-100) */
  evidenceStrength: number;

  /** 整体置信度 (0-100) */
  confidence: number;

  /** 信息缺口列表 */
  gaps: string[];

  /** 改进建议 */
  recommendations: string[];

  /** 质量等级 */
  qualityLevel: 'excellent' | 'good' | 'fair' | 'poor';

  /** 详细评分 */
  breakdown: {
    technicalSkillsCoverage: number;
    softSkillsCoverage: number;
    experienceVerification: number;
    culturalFitAssessment: number;
    evidenceQuality: number;
  };
}

/**
 * 评估候选人画像的质量
 */
async assessProfileQuality(profile: CandidateProfile): Promise<ProfileQualityMetrics> {
  const profileData = profile.profileData as ProfileData;

  // 1. 计算完整度评分
  const completeness = this.calculateCompleteness(profileData);

  // 2. 计算证据强度评分
  const evidenceStrength = this.calculateEvidenceStrength(profileData);

  // 3. 计算整体置信度
  const confidence = Math.round(completeness * 0.4 + evidenceStrength * 0.6);

  // 4. 识别信息缺口
  const gaps = this.identifyGaps(profileData);

  // 5. 生成改进建议
  const recommendations = this.generateRecommendations(profileData, gaps, confidence);

  // 6. 确定质量等级
  const qualityLevel = this.determineQualityLevel(confidence);

  // 7. 详细评分分解
  const breakdown = this.calculateDetailedBreakdown(profileData);

  const metrics: ProfileQualityMetrics = {
    completeness,
    evidenceStrength,
    confidence,
    gaps,
    recommendations,
    qualityLevel,
    breakdown
  };

  this.log('info', '画像质量评估完成', {
    profileId: profile.id,
    qualityLevel,
    confidence,
    gapsCount: gaps.length,
    recommendationsCount: recommendations.length
  });

  return metrics;
}

/**
 * 计算信息完整度 (0-100)
 */
private calculateCompleteness(profileData: ProfileData): number {
  let score = 0;
  let maxScore = 0;

  // 技术技能 (20分)
  maxScore += 20;
  if (profileData.technicalSkills && profileData.technicalSkills.length > 0) {
    score += 10;
    if (profileData.technicalSkills.length >= 5) score += 5;
    if (profileData.technicalSkills.some(s => s.proficiency === 'expert' || s.proficiency === 'advanced')) score += 5;
  }

  // 软技能 (15分)
  maxScore += 15;
  if (profileData.softSkills && profileData.softSkills.length > 0) {
    score += 8;
    if (profileData.softSkills.length >= 3) score += 4;
    if (profileData.softSkills.some(s => s.examples && s.examples.length > 0)) score += 3;
  }

  // 工作经验 (25分)
  maxScore += 25;
  if (profileData.experience) {
    score += 10;
    if (profileData.experience.totalYears > 0) score += 5;
    if (profileData.experience.positions && profileData.experience.positions.length > 0) score += 5;
    if (profileData.experience.positions?.some(p => p.keyAchievements.length > 0)) score += 5;
  }

  // 教育背景 (10分)
  maxScore += 10;
  if (profileData.education) {
    score += 5;
    if (profileData.education.level && profileData.education.field) score += 5;
  }

  // 文化契合度 (15分)
  maxScore += 15;
  if (profileData.culturalFit) {
    score += 8;
    if (profileData.culturalFit.workStyle) score += 3;
    if (profileData.culturalFit.motivations && profileData.culturalFit.motivations.length > 0) score += 4;
  }

  // 职业发展 (15分)
  maxScore += 15;
  if (profileData.careerTrajectory) {
    score += 8;
    if (profileData.careerTrajectory.progression) score += 4;
    if (profileData.careerTrajectory.growthAreas && profileData.careerTrajectory.growthAreas.length > 0) score += 3;
  }

  return Math.round((score / maxScore) * 100);
}

/**
 * 计算证据强度 (0-100)
 */
private calculateEvidenceStrength(profileData: any): number {
  let totalEvidence = 0;
  let strongEvidenceCount = 0;
  let totalConfidence = 0;

  // 从所有字段提取证据
  const evidence = this.extractAllEvidence(profileData);

  totalEvidence = evidence.length;

  if (totalEvidence === 0) {
    return 0;  // 无证据
  }

  // 计算强证据比例
  strongEvidenceCount = evidence.filter(e =>
    e.strength === 'direct' || e.strength === 'strong'
  ).length;

  // 计算平均置信度
  totalConfidence = evidence.reduce((sum, e) => sum + (e.confidence || 50), 0);
  const averageConfidence = totalConfidence / totalEvidence;

  // 综合评分
  const strongEvidenceRatio = strongEvidenceCount / totalEvidence;
  const evidenceDensity = Math.min(totalEvidence / 20, 1);  // 20条证据为满分

  const score = (
    strongEvidenceRatio * 40 +      // 强证据比例占40%
    (averageConfidence / 100) * 40 + // 平均置信度占40%
    evidenceDensity * 20             // 证据数量占20%
  );

  return Math.round(score);
}

/**
 * 提取所有证据（用于质量评估）
 */
private extractAllEvidence(profileData: any): Evidence[] {
  const evidence: Evidence[] = [];

  // 技能证据
  ['technicalSkills', 'softSkills'].forEach(skillType => {
    if (profileData[skillType]) {
      profileData[skillType].forEach((skill: any) => {
        if (skill.evidence) evidence.push(...skill.evidence);
      });
    }
  });

  // 经验证据
  if (profileData.experience?.evidence) {
    evidence.push(...profileData.experience.evidence);
  }

  // 其他证据源...
  if (profileData.evidenceSummary?.evidence) {
    evidence.push(...profileData.evidenceSummary.evidence);
  }

  return evidence;
}

/**
 * 识别信息缺口
 */
private identifyGaps(profileData: ProfileData): string[] {
  const gaps: string[] = [];

  // 检查技术技能
  if (!profileData.technicalSkills || profileData.technicalSkills.length < 3) {
    gaps.push('技术技能信息不足（建议至少3项）');
  }

  // 检查软技能
  if (!profileData.softSkills || profileData.softSkills.length < 2) {
    gaps.push('软技能信息不足（建议至少2项）');
  }

  // 检查工作经验
  if (!profileData.experience || !profileData.experience.positions || profileData.experience.positions.length === 0) {
    gaps.push('缺少工作经历详情');
  }

  // 检查教育背景
  if (!profileData.education || !profileData.education.level) {
    gaps.push('缺少教育背景信息');
  }

  // 检查文化契合度
  if (!profileData.culturalFit) {
    gaps.push('未评估文化契合度');
  }

  // 检查职业发展
  if (!profileData.careerTrajectory) {
    gaps.push('未分析职业发展轨迹');
  }

  // 检查组织契合度
  if (!profileData.organizationalFit) {
    gaps.push('未进行组织契合度评估');
  }

  return gaps;
}

/**
 * 生成改进建议
 */
private generateRecommendations(
  profileData: ProfileData,
  gaps: string[],
  confidence: number
): string[] {
  const recommendations: string[] = [];

  // 基于置信度的建议
  if (confidence < 60) {
    recommendations.push('整体信息质量较低，建议安排深度面试以获取更多证据');
  } else if (confidence < 80) {
    recommendations.push('信息质量中等，建议针对信息缺口进行补充面试');
  }

  // 基于信息缺口的建议
  if (gaps.includes('技术技能信息不足（建议至少3项）')) {
    recommendations.push('安排技术面试，深入评估候选人的技术能力');
  }

  if (gaps.includes('软技能信息不足（建议至少2项）')) {
    recommendations.push('通过行为面试（STAR方法）收集更多软技能证据');
  }

  if (gaps.includes('未评估文化契合度')) {
    recommendations.push('安排文化契合度面试，了解候选人的工作风格和价值观');
  }

  if (gaps.includes('未进行组织契合度评估')) {
    recommendations.push('评估候选人与团队、组织的契合度');
  }

  // 基于证据强度的建议
  const evidence = this.extractAllEvidence(profileData);
  const weakEvidenceRatio = evidence.filter(e => e.strength === 'weak' || e.strength === 'inferential').length / evidence.length;

  if (weakEvidenceRatio > 0.5) {
    recommendations.push('当前证据较多基于推断，建议通过实际案例或测试进行验证');
  }

  // 如果没有特定建议，给出通用建议
  if (recommendations.length === 0) {
    recommendations.push('画像质量良好，建议继续通过面试深化理解');
  }

  return recommendations;
}

/**
 * 确定质量等级
 */
private determineQualityLevel(confidence: number): 'excellent' | 'good' | 'fair' | 'poor' {
  if (confidence >= 85) return 'excellent';
  if (confidence >= 70) return 'good';
  if (confidence >= 55) return 'fair';
  return 'poor';
}

/**
 * 计算详细评分分解
 */
private calculateDetailedBreakdown(profileData: ProfileData): ProfileQualityMetrics['breakdown'] {
  return {
    technicalSkillsCoverage: this.scoreSkillsCoverage(profileData.technicalSkills, 'technical'),
    softSkillsCoverage: this.scoreSkillsCoverage(profileData.softSkills, 'soft'),
    experienceVerification: this.scoreExperienceVerification(profileData.experience),
    culturalFitAssessment: this.scoreCulturalFit(profileData.culturalFit),
    evidenceQuality: this.calculateEvidenceStrength(profileData)
  };
}

private scoreSkillsCoverage(skills: any[] | undefined, type: 'technical' | 'soft'): number {
  if (!skills || skills.length === 0) return 0;

  const targetCount = type === 'technical' ? 5 : 3;
  const coverageScore = Math.min(skills.length / targetCount, 1) * 60;

  const evidenceScore = skills.filter(s => s.evidence && s.evidence.length > 0).length / skills.length * 40;

  return Math.round(coverageScore + evidenceScore);
}

private scoreExperienceVerification(experience: any): number {
  if (!experience) return 0;

  let score = 0;

  if (experience.totalYears > 0) score += 30;
  if (experience.positions && experience.positions.length > 0) score += 40;
  if (experience.positions?.some((p: any) => p.keyAchievements?.length > 0)) score += 30;

  return score;
}

private scoreCulturalFit(culturalFit: any): number {
  if (!culturalFit) return 0;

  let score = 0;

  if (culturalFit.workStyle) score += 40;
  if (culturalFit.motivations && culturalFit.motivations.length > 0) score += 30;
  if (culturalFit.preferences && culturalFit.preferences.length > 0) score += 30;

  return score;
}
```

**在画像生成时自动评估质量**:

```typescript
// server/services/candidateProfileService.ts

async buildInitialProfile(
  candidateId: string,
  resumeAnalysis: ResumeAnalysis,
  jobId?: string
): Promise<CandidateProfile> {
  // ... 现有逻辑

  const profile = await storage.createCandidateProfile({
    // ... 现有字段
  });

  // ✨ 新增：评估画像质量
  const qualityMetrics = await this.assessProfileQuality(profile);

  this.log('info', '初始画像质量评估', {
    profileId: profile.id,
    qualityLevel: qualityMetrics.qualityLevel,
    confidence: qualityMetrics.confidence,
    gaps: qualityMetrics.gaps,
    recommendations: qualityMetrics.recommendations
  });

  // 可选：将质量评估结果存储到画像中
  // 或返回给前端展示

  return profile;
}
```

**前端展示质量指标**:

```typescript
// client/src/components/profile-quality-indicator.tsx
interface ProfileQualityIndicatorProps {
  qualityMetrics: ProfileQualityMetrics;
}

export function ProfileQualityIndicator({ qualityMetrics }: ProfileQualityIndicatorProps) {
  const { qualityLevel, confidence, gaps, recommendations, breakdown } = qualityMetrics;

  const qualityConfig = {
    excellent: { color: 'green', label: '优秀', icon: CheckCircle2 },
    good: { color: 'blue', label: '良好', icon: ThumbsUp },
    fair: { color: 'yellow', label: '一般', icon: AlertCircle },
    poor: { color: 'red', label: '较差', icon: XCircle }
  };

  const config = qualityConfig[qualityLevel];

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <config.icon className={`h-5 w-5 text-${config.color}-600`} />
          画像质量评估
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* 整体评分 */}
        <div className="flex items-center justify-between">
          <span className="text-sm font-medium">整体置信度</span>
          <div className="flex items-center gap-2">
            <Progress value={confidence} className="w-32" />
            <span className="text-lg font-bold">{confidence}%</span>
          </div>
        </div>

        {/* 详细评分 */}
        <div className="space-y-2">
          <h4 className="text-sm font-medium">详细评分</h4>
          <div className="grid grid-cols-2 gap-2 text-sm">
            <div>技术技能: {breakdown.technicalSkillsCoverage}%</div>
            <div>软技能: {breakdown.softSkillsCoverage}%</div>
            <div>经验验证: {breakdown.experienceVerification}%</div>
            <div>文化契合: {breakdown.culturalFitAssessment}%</div>
            <div className="col-span-2">证据质量: {breakdown.evidenceQuality}%</div>
          </div>
        </div>

        {/* 信息缺口 */}
        {gaps.length > 0 && (
          <div className="space-y-2">
            <h4 className="text-sm font-medium text-amber-700">信息缺口</h4>
            <ul className="text-sm text-muted-foreground space-y-1">
              {gaps.map((gap, i) => (
                <li key={i} className="flex items-start gap-2">
                  <AlertCircle className="h-4 w-4 shrink-0 mt-0.5" />
                  {gap}
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* 改进建议 */}
        {recommendations.length > 0 && (
          <div className="space-y-2">
            <h4 className="text-sm font-medium text-blue-700">改进建议</h4>
            <ul className="text-sm text-muted-foreground space-y-1">
              {recommendations.map((rec, i) => (
                <li key={i} className="flex items-start gap-2">
                  <Lightbulb className="h-4 w-4 shrink-0 mt-0.5" />
                  {rec}
                </li>
              ))}
            </ul>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

#### 实施步骤

1. **添加质量评估方法**（2-3小时）
2. **集成到画像生成流程**（1小时）
3. **创建前端质量指标组件**（2-3小时）
4. **编写测试**（2小时）
5. **在候选人详情页展示**（1小时）

#### 预期收益

- ✅ 用户了解画像质量
- ✅ 提供可操作的改进建议
- ✅ 量化信息完整度
- ✅ 指导下一步面试重点

---

### 🟢 轻微问题 5: 前端性能优化空间

#### 问题描述

**影响范围**: `client/src/components/profile-evolution-timeline.tsx`

**严重程度**: 🟢 **低** - 仅在极端场景下影响性能

**当前实现**:
- ✅ 使用 `useMemo` 优化计算
- ✅ 响应式设计
- ✅ 无障碍支持
- ⚠️ 未使用虚拟滚动（20+ 版本时可能卡顿）

#### 影响评估

| 影响维度 | 严重程度 | 说明 |
|---------|---------|------|
| **性能** | 🟢 低 | 仅在20+版本时影响 |
| **用户体验** | 🟢 低 | 大多数场景流畅 |
| **发生概率** | 🟢 低 | 很少有候选人经历20+轮面试 |
| **修复难度** | 🟢 低 | 使用 react-window 即可 |

#### 修复方案

**可选优化：虚拟滚动**（仅在需要时实施）

```bash
npm install react-window
```

```typescript
// client/src/components/profile-evolution-timeline.tsx
import { FixedSizeList as List } from 'react-window';

export const ProfileEvolutionTimeline = ({ profiles, onSelectProfile }) => {
  // 如果版本数量超过20，启用虚拟滚动
  const USE_VIRTUAL_SCROLL = profiles.length > 20;

  if (USE_VIRTUAL_SCROLL) {
    const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {
      const profile = timelineData.items[index].profile;

      return (
        <div style={style}>
          <TimelineNode
            profile={profile}
            // ... 其他 props
          />
        </div>
      );
    };

    return (
      <List
        height={800}
        itemCount={profiles.length}
        itemSize={250}
        width="100%"
      >
        {Row}
      </List>
    );
  }

  // 正常渲染（< 20 个版本）
  return (
    <div>
      {timelineData.items.map(({ profile }) => (
        <TimelineNode key={profile.id} profile={profile} />
      ))}
    </div>
  );
};
```

---

## 📅 实施计划

### 第 1 周: 严重问题修复

| 任务 | 优先级 | 预计工时 | 负责人 |
|------|--------|---------|--------|
| **修复版本号并发问题** | 🔴 P0 | 4 小时 | 后端开发 |
| - 实现事务 + 行锁 | | 2 小时 | |
| - 编写单元测试 | | 1 小时 | |
| - 并发压测验证 | | 1 小时 | QA |
| **完善证据提取逻辑** | 🟡 P1 | 5 小时 | 后端开发 |
| - 添加所有证据提取方法 | | 3 小时 | |
| - 实现去重逻辑 | | 1 小时 | |
| - 编写测试 | | 1 小时 | |

### 第 2-3 周: 中等问题改进

| 任务 | 优先级 | 预计工时 | 负责人 |
|------|--------|---------|--------|
| **优化 AI 提示词管理** | 🟡 P1 | 6 小时 | 后端开发 |
| - Token 估算和压缩 | | 3 小时 | |
| - 智能摘要逻辑 | | 2 小时 | |
| - 测试和调优 | | 1 小时 | |
| **添加画像质量评分** | 🟢 P2 | 8 小时 | 全栈开发 |
| - 后端评分算法 | | 4 小时 | |
| - 前端质量指标组件 | | 3 小时 | |
| - 集成和测试 | | 1 小时 | |

### 第 4 周: 测试和发布

| 任务 | 优先级 | 预计工时 | 负责人 |
|------|--------|---------|--------|
| **集成测试** | 🔴 P0 | 4 小时 | QA |
| **性能测试** | 🟡 P1 | 2 小时 | QA |
| **文档更新** | 🟡 P1 | 2 小时 | 技术写作 |
| **生产部署** | 🔴 P0 | 2 小时 | DevOps |

**总工时估算**: 约 **33 小时**（4 个工作日）

---

## 🧪 测试计划

### 单元测试

- [ ] `createCandidateProfile` 并发安全测试
- [ ] `extractEvidenceFromProfile` 完整性测试
- [ ] Token 估算准确性测试
- [ ] 画像质量评分算法测试

### 集成测试

- [ ] 完整的画像生成流程测试
- [ ] 多轮面试更新流程测试
- [ ] 证据链整合测试

### 性能测试

- [ ] 并发创建画像压测（100 并发）
- [ ] 大量证据场景测试（500+ 条证据）
- [ ] 多版本渲染性能测试（30+ 版本）

### 回归测试

- [ ] 确保现有功能不受影响
- [ ] 验证前端展示正常
- [ ] 验证 API 响应格式不变

---

## 📊 成功指标

### 技术指标

- [ ] 版本号冲突率 = 0%
- [ ] 证据提取完整度 > 95%
- [ ] AI Token 使用效率提升 30%+
- [ ] 画像质量评分覆盖率 = 100%

### 业务指标

- [ ] 画像生成成功率 > 99%
- [ ] 用户满意度评分 > 4.5/5
- [ ] 画像更新响应时间 < 10s

---

## 🔧 回滚计划

如果修复后出现问题，按以下步骤回滚：

1. **立即回滚代码**
   ```bash
   git revert <commit-hash>
   git push origin main
   ```

2. **数据库回滚**（如果有 schema 变更）
   ```bash
   psql -h your-host -U postgres -d your-db < backup_YYYYMMDD_HHMMSS.sql
   ```

3. **通知团队和用户**

4. **分析失败原因，重新计划修复**

---

## 📚 附录

### A. 相关文件清单

**后端文件**:
- `shared/schema.ts:200-244` - 画像表定义
- `server/storage.ts:1074-1126` - 画像创建逻辑
- `server/services/candidateProfileService.ts` - 画像服务（1553 行）
- `server/routes.ts:1787-1821, 2213-2269` - API 路由

**前端文件**:
- `client/src/components/profile-evolution-timeline.tsx` - 时间线组件
- `client/src/components/profile-card-enhanced.tsx` - 画像卡片
- `client/src/pages/candidate-detail.tsx` - 候选人详情页

### B. 数据库表结构

```sql
CREATE TABLE candidate_profiles (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  candidate_id VARCHAR NOT NULL REFERENCES candidates(id) ON DELETE CASCADE,
  job_id VARCHAR REFERENCES jobs(id) ON DELETE SET NULL,
  version INTEGER NOT NULL,  -- 版本号（自动递增）
  stage TEXT NOT NULL,       -- 阶段标记
  profile_data JSONB NOT NULL,
  overall_score DECIMAL(5, 2),
  data_sources JSONB,
  gaps JSONB,
  strengths JSONB,
  concerns JSONB,
  ai_summary TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(candidate_id, version)  -- 版本唯一性约束
);
```

### C. 关键指标监控

```typescript
// 建议添加的监控指标
const MONITORING_METRICS = {
  // 画像生成
  'profile.creation.success_rate': '画像创建成功率',
  'profile.creation.duration_ms': '画像创建耗时',
  'profile.version_conflicts': '版本号冲突次数',

  // AI 调用
  'ai.token_usage': 'AI Token 使用量',
  'ai.call_duration_ms': 'AI 调用耗时',
  'ai.error_rate': 'AI 调用失败率',

  // 证据系统
  'evidence.extraction_count': '证据提取数量',
  'evidence.contradiction_count': '证据矛盾数量',
  'evidence.quality_score': '证据质量分数',

  // 画像质量
  'profile.quality.average_score': '平均质量分数',
  'profile.quality.gaps_count': '平均信息缺口数量',
};
```

---

## ✅ 下一步行动

1. **审查报告**: 请仔细审查本报告，确认修复方案
2. **确认优先级**: 确认是否同意建议的优先级排序
3. **资源分配**: 分配开发资源和时间表
4. **开始修复**: 从 P0 严重问题开始逐步修复
5. **持续跟踪**: 使用项目管理工具跟踪进度

---

**报告生成者**: Claude (AI Assistant)
**审查状态**: 待审查
**最后更新**: 2025-10-09
